## 목차

[Java의 특징](#Java의-특징)\
[JVM의 역할](#JVM의-역할)\
[추상 클래스와 인터페이스](#추상-클래스와-인터페이스)\
[가비지 컬렉션](#가비지-컬렉션)\
[가비지 컬렉션 과정](#가비지-컬렉션-과정)\
[SSR](#SSR)\
[MVC](#MVC)\
[API](#API)\
[REST](#REST)\
[객체지향](#객체지향)\
[객체지향의 특징](#객체지향의-특징)\
[객체지향의 설계원칙](#객체지향의-설계원칙)\
[메소드](#메소드)\
[클래스](#클래스)\
[객체](#객체)\
[생성자](#생성자)\
[Synchronized](#Synchronized)\
[접근제한자](#접근제한자)\
[static](#static)\
[Error와 Exception](#Error와-Exception)\
[CheckedException, UncheckedException](#CheckedException,-UncheckedException)\
[Optional](#Optional)\
[Collection 프레임워크](#Collection-프레임워크)\
[제네릭](#제네릭)\
[오버로딩](#오버로딩)\
[오버라이딩](#오버라이딩)\
[가상함수](#가상함수)\
[동기화객체](#동기화객체)\
[동적할당](#동적할당)\
[메모리단편화](#메모리단편화)\
[퀵소트](#퀵소트)\
[힙](#힙)\
[let과 const](#let-const)

[데이터베이스의 특징](#데이터베이스의-특징)\
[데이터베이스 언어](#데이터베이스-언어)\
[inner join](#inner-join)\
[outer join](#outer-join)\
[Group By](#Group-By)\
[Delete](#Delete)\
[Truncate](#Truncate)\
[Drop](#Drop)\
[Having, Where의 차이](#Having,-Where의-차이)\
[인덱스](#인덱스)\
[클러스터 인덱스와 넌클러스터 인덱스](#클러스터-인덱스와-넌클러스터-인덱스)\
[mysql과 mongodb의 차이](#mysql과-mongodb의-차이)\
[mysql, nosql의 장단점](#mysql,-nosql의-장단점)\
[DB 트렌젝션 Transaction](#DB-트렌젝션-Transaction)\
[프라이머리 키(기본키), 컴파운드 키](<#프라이머리-키(기본키),-컴파운드-키>)\
[외래 키](#Foreign-Key)\
[db procedure](#db-procedure)\
[SQL Injection](#SQL-Injection)\
[SQL Injection 방어 및 방지 방법](#SQL-Injection-방어-및-방지-방법)\
[Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이](#Elastic-Search의-키워드-검색과-RDBMS의-LIKE-검색의-차이)\
[옵티마이저](#옵티마이저)\
[데이터베이스 클러스터링](#데이터베이스-클러스터링)\
[데이터베이스 리플레케이션](#데이터베이스-리플레케이션)

[웹사이트 접속 순서](#웹사이트-접속-순서)\
[HTTP, HTTPS란?](#HTTP,-HTTPS란?)\
[쿠키, 세션](#쿠키,-세션)\
[GET/POST](#GET/POST)\
[TCP와 UDP의 차이](#TCP와-UDP의-차이)\
[3-way handshaking, 4-way handshaking](#3-way-handshaking,-4-way-handshaking)\
[OSI 7 Layer](#OSI-7-Layer)\
[세션 기반 인증과 토큰 기반 인증](#세션-기반-인증과-토큰-기반-인증)\
[세션 기반 인증과 토큰 기반 인증이 적합한 경우](#세션-기반-인증과-토큰-기반-인증이-적합한-경우)\
[JWT](#JWT)\
[HTTP 상태 코드](#HTTP-상태-코드)

[운영체제](#운영체제)\
[프로세스의 특징](#프로세스의-특징)\
[스레드의 특징](#스레드의-특징)\
[프로세스와 쓰레드의 차이](#프로세스와-쓰레드의-차이)\
[메모리 영역](#메모리-영역)\
[멀티 프로세스와 멀티 스레드의 특징](#멀티-프로세스와-멀티-스레드의-특징)\
[멀티 스레드의 동시성과 병렬성](#멀티-스레드의-동시성과-병렬성)\
[멀티 쓰레드 환경 주의사항](#멀티-쓰레드-환경-주의사항)\
[데드락](#데드락)\
[데드락의 조건](#데드락의-조건)\
[콘보이 현상](#콘보이-현상)\
[선점형 스케쥴린, 비선점형 스케쥴링의 차이](#선점형-스케쥴린,-비선점형-스케쥴링의-차이)\
[동기와 비동기](#동기와-비동기)\
[임계 영역, Critical Section](#임계-영역,-Critical-Section)\
[뮤텍스와 세마포어](#뮤텍스와-세마포어)\
[가상 메모리](#가상-메모리)

[싱글톤 패턴](#싱글톤-패턴)\
[AOP](#AOP)\
[IoC](#IoC)\
[DI](#DI)\
[Bean](#Bean)\
[스프링 필터와 인터셉터의 차이점](#스프링-필터와-인터셉터의-차이점)\
[Entity](#Entity)\
[Object](#Object)\
[Instance](#Instance)\
[인스턴스화 된다가 무슨 의미인가](#인스턴스화-된다가-무슨-의미인가)\
[JPA에서 Entity를 설계할 때 주의점](#JPA에서-Entity를-설계할-때-주의점)\
[DTO를 사용하는 이유](#DTO를-사용하는-이유)\
[N+1 문제](#N+1-문제)\
[생성자 Injection을 사용하는 이유](#생성자-Injection을-사용하는-이유)\
[테스트코드를 사용하는 이유](#테스트코드를-사용하는-이유)\
[JPA](#JPA)\
[JPA의 장점과 단점](#JPA의-장점과-단점)\
[MVC 진행 방식](#MVC-진행-방식)\
[Spring Security](#Spring-Security)\
[JWT, OAuth](#JWT,-OAuth)\
[영속성 컨텍스트](#영속성-컨텍스트)\
[@RequestBody, @RequestParam, @ModelAttribute](#@RequestBody,-@RequestParam,-@ModelAttribute)\
[Lombok 라이브러리](#Lombok-라이브러리)\
[Servlet](#Servlet)\
[@Transactional의 동작 원리](#@Transactional의-동작-원리)\
[@Transactional의 readOnly를 사용하는 이유](#@Transactional의-readOnly를-사용하는-이유)\

[Wrapper Class](#Wrapper-Class)\
[String, StringBuffer, StringBuilder](#String,-StringBuffer,-StringBuilder)\
[String 객체가 불변인 이유](#String-객체가-불변인-이유)\

### Java의 특징

Java는 객체지향 프로그래밍 언어이다.\
기본 자료형을 제외한 모든 요소들이 객체로 표현되고, \
객체 지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어이다.

- 장점

  - JVM(자바가상머신) 위에서 동작하기 때문에 운영체제에 독립적이다.
  - GabageCollector를 통한 자동적인 메모리 관리가 가능하다.

- 단점
  - JVM 위에서 동작하기 때문에 실행 속도가 상대적으로 느리다.
  - 다중 상속이나 타입에 엄격하며, 제약이 많다.

### JVM의 역할

JVM이란 자바 가상 머신의 약자로, 자바와 OS 사이의 중개자 역할을 수행하여 \
JAVA가 OS에 구애받지 않고 독립적으로 작동할 수 있도록 한다.

JVM은 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석 해주는 역할을 하고 \
가비지컬렉션을 통해 자동적인 메모리 관리를 해줌.

### 추상 클래스와 인터페이스

추상 클래스는 클래스 내의 추상 메소드가 하나 이상 포함되거나, abstract 키워드를 사용해 정의된다.

인터페이스는 모든 메소드가 추상 메소드로만 이루어져 있는 것을 의미한다.

둘 모두 new 키워드를 사용해 인스턴스를 생성할 수 없으며,\
사용하기 위해선 하위 클래스에서 구현 및 확장해야 한다.

하지만 인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 \
특정한 메소드가 반드시 존재하도록 강제하고,\
추상 클래스는 상속받는 클래스들의 공통적인 로직을 추상화해 \
기능 확장을 위해 사용된다는 차이점이 존재한다.

또한 추상클래스는 다중상속이 불가능하지만, 인터페이스는 다중상속이 가능하다.

### 가비지 컬렉션

JVM의 메모리 관리 기법 중 하나로,\
시스템에서 동적으로 할당됐던 메모리 영역 중에서 필요없어진 메모리를 제거하여\
메모리를 관리해주는 기법.

### 가비지 컬렉션 과정

1. JVM이 어플리케이션의 실행을 잠시 멈춘다.
2. GC를 실행하는 쓰레드를 제외한 모든 쓰레드의 작업이 중단된다.
3. 사용하지 않는 메모리를 제거한다.
4. 작업이 재개된다.

### SSR

서버에서 렌더링 준비를 끝마친 상태로 클라이언트에 전달하는 방식을 의미합니다.

유저가 요청을 전송하면 서버는 즉시 렌더링 가능한 html 파일을 생성하고, \
클라이언트에 전달되는 순간 html이 즉시 렌더링 됩니다.

자바스크립트는 받아오기 전이기 때문에 조작은 불가능하지만, \
사용자가 무언가를 **볼 수** 있습니다.

### MVC

애플리케이션을 세가지역할로 구분한 개발 방법론.

사용자가 Controller를 조작하게 되면 Controller는 Model을 통해서 데이터를 가져오고, \
그 정보를 바탕으로 시작적인 표현을 담당하는 View에서 제어해 사용자에게 전달.

1. 사용자가 웹 사이트에 접속한다. (User)
2. Controller는 사용자가 요청한 웹 페이지를 서비스하기 위해서 모델을 호출한다.
3. 모델은 데이터베이스나 파일과 같은 데이터 소스를 제어한 후에 그 결과를 리턴한다.
4. Controller는 Model이 리턴한 결과를 View에 반영한다.
5. 데이터가 반영된 View는 사용자에게 보여진다.

### API

응용프로그램에서 사용할 수 있도록 \
운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있도록 만든 인터페이스

API를 사용하면 구현 방식을 알지 못해도 서비스가 서로 커뮤니케이션 할 수 있으며 \
애플리케이션 개발을 간소화하여 시간과 비용을 절약할 수 있음.

### REST

Representational State Transfer의 약자로, \
HTTP URI를 통해 자원을 명시하고, \
HTTP Method(post, get, put, delete)를 통해 \
해당 자원에 대한 CRUD operation을 적용하는것을 의미한다.

### 객체지향

하나의 소프트웨어를 여러 객체간의 상호작용으로 정의하고, 이에 따라 객체를 중심으로 소프트웨어를 설계하는 개발 방법론

객체지향의 특성은 캡슐화, 상속, 추상화, 다형성 등이 있음.

### 객체지향의 특징

캡슐화 : 데이터 보호와 은닉을 위해, 서로 연관있는 속성과 기능을 하나의 캡슐로 만들어 외부로부터 보호하는 것

추상화 : 어떤 대상을 구현할 때, 이 대상의 본질적인 특징을 정의하고, 이것에 기반하여 대상을 객체로 구현하는 것

상속 : 자식 클래스에서 부모 클래스의 속성과 기능을 그대로 이어받되, 변경이 필요한 경우 해당 기능만 수정해서 사용할 수 있게 하는 것.

다형성 : 특정 객체의 속성이나 기능이 상황에 따라 여러 형태를 가질 수 있는 것. 대표적으로 오버로딩, 오버라이딩

### 객체지향의 설계원칙

1. SRP - 단일 책임 원칙 : 한 클래스는 하나의 책임만 가져야 한다.
2. OCP - 개방-폐쇄 원칙 : 확장에는 열려있고, 수정에는 닫혀있어야 한다.
3. LSP - 리스코프 치환 원칙 : 하위 타입은 항상 상위 타입을 대체 할 수 있어야 한다.
4. ISP - 인터페이스 분리 원칙 : 인터페이스 내에 메소드는 최소한 일수록 좋다. \
   즉, 하나의 공통 인터페이스보단 여러개의 구체적인 인터페이스가 낫다.
5. DIP - 의존관계 역전 원칙 : 구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺어라. DIP 원칙을 따르는 가장 인기 있는 방법은 의존성 주입(DI)이다.

### 메소드

필드에 저장된 정보를 제어하기 위한 명령들의 모임

### 클래스

객체를 만들어내기 위해 변수와 메소드를 정의하는 설계도, 혹은 틀.

### 객체

클래스를 기반으로 생성되며, 자신의 고유 이름과 상태(필드), 행동(메소드)을 갖는다.

### 생성자

클래스와 같은 이름의 메소드로, 객체를 생성할 때 자동으로 호출되는 메소드.\
생성자는 오버로딩이 가능하다.

### Synchronized

여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, \
현재 데이터를 사용하고 있는 쓰레드를 제외하고 \
나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념.

자바에서 Synchronized 키워드를 제공해 멀티 쓰레드 환경에서 \
쓰레드간 동기화를 시켜 데이터의 thread-safe를 보장.

### 접근제한자

변수 또는 메소드의 접근 범위를 설정해주기 위해서 사용하는 Java의 예약어.\
총 4 가지 종류가 있다.

- public - 접근 제한이 없다. (같은 프로젝트 내 어디서든 사용 가능)
- protected - 해당 패키지 내, 다른 패키지에서 상속받아 자손 클래스에서 접근 가능하다.
- (default) - 해당 패키지 내에서만 접근 가능
- private - 해당 클래스에서만 접근 가능

### static

변수나 메소드를 선언할 때 사용되는 키워드로, \
해당 변수나 메소드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 \
객체를 생성하지 않더라도, 클래스 로딩이 끝난 뒤 바로 사용할 수 있다.

모든 객체가 메모리를 공유한다는 특징이 존재하며,\
GC 관리영역 밖에 있기 때문에, 프로그램이 종료될 때까지 메모리에 값이 유지된다.

자주 변하지 않는 값이나 공통으로 사용되는 공용 자원에 대한 접근에 있어,\
매번 메모리에 로딩되거나 값을 읽어들이지 않고, 전역변수의 개념으로 접근해 \
메모리 비용을 줄이고, 효율을 높일 수 있다.

### Error와 Exception

Error는 실행 중 일어날 수 있는 치명적 오류를 의미한다.\
컴파일 시점에 체크할 수 없고, \
오류가 발생하면 프로그램은 비정상 종료되며 예측 불가능한 UncheckedException에 속한다.

반면, Exception은 Error보다 비교적 경미한 오류이며, \
try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있다.

### CheckedException, UncheckedException

CheckedException은 실행 전 예측 가능한 예외를 의미하며, 반드시 예외처리를 해야한다.\
대표적으로 IOException, ClassNotFoundException이 존재한다.

UnCheckedException은 실행 후 알 수 있는 예외를 의미하며, 따로 예외처리를 하지 않아도 된다.\
대표적으로 NullPointerException이 존재한다.

### Optional

NullPointerException을 방지하기 위해 사용되는 방법으로,\
Optional을 사용해 Null로 인한 예외가 발생하지 않도록 도와준다.

### Collection 프레임워크

다수의 데이터를 쉽고, 효과적으로 관리할 수 있도록\
표준화된 방법들을 제공하는 클래스의 집합.

List, Set, Map 인터페이스를 기준으로 여러 구현체가 존재한다.

### 제네릭

클래스나 메소드에서 사용할 데이터 타입을 하나로 지정하지 않고, \
컴파일시에 미리 지정하는 방법.

제네릭 타입을 사용함으로써, 잘못된 타입이 사용될 수 있는 문제를 \
컴파일 과정에서 미리 제거할 수 있다.

### 오버로딩

클래스에 동일한 이름의 메소드를 선언할 수 있는 방법

같은 메소드 이름, 다른 매개변수로 다수의 메소드를 중복 정의.

### 오버라이딩

같은 메소드 이름, 같은 매개변수로 부모 클래스의 메소드를 재정의.

### 가상함수

파생되는 클래스에서 재 정의 될 것으로 기대되는 멤버 함수.

### 동기화객체

커널에서 제공하는 객체로, 쓰레드를 사용할 때 문제되는 자원의 공유 시 충돌에 대한 해법을 제시. 뮤텍스와 세마포어가 대표적.

### 동적할당

프로그램 실행 시간동안 사용 할 메모리 공간을 할당하는 것을 의미. \
상황에 따라 원하는 크기 만큼의 메모리가 할당되고, \
이미 할당된 메모리라도 언제든 크기 조정이 가능하다.

### 메모리단편화

램에서 메모리의 공간이 작은 조각으로 나뉘어져 사용가능한 메모리가 충분히 존재하지만, 할당이 불가능한 상태.

### 퀵소트

임의의 원소 하나를 피벗으로 삼아, \
그보다 작은 것을 앞으로 빼낸 뒤 피벗을 옮겨 데이터를 피벗보다 작은 것, 피벗, 피벗보다 큰 것으로 나눈다.

그 뒤 피벗보다 작은것과 피벗보다 큰 것에서 같은 작업을 반복하여 각각 나뉜 데이터의 개수가 0, 혹은 1이 될 때 까지 반복.

### 힙

완전 이진트리의 일종으로, 우선순위큐를 위해 만들어진 자료구조.\
힙은 큰 값이 상위 레벨에 존재하고, \
작은 값이 하위레벨에 존재하는 느슨한 정렬 상태를 유지합니다.

### let const

var 변수는 3가지 문제점이 존재한다.\

1. 중복 선언이 가능하다
2. 블록 레벨이 아닌 함수 레벨 스코프이다
3. 변수 호이스팅(변수 선언이 코드의 선두로 끌어올려진다)

let과 const는 이 세 가지 문제점이 없기 때문에 사용해야 한다.

### 데이터베이스의 특징

실시간 처리에 대한 응답이 가능해야하며, \
새로운 데이터 삽입, 삭제, 갱신으로 항상 최신 데이터가 유지되어야 합니다.

또한 서로 다른 목적을 갖는 여러 사용자를 위한 것이므로, \
다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야하고, \
데이터를 참조할 때, 데이터의 위치가 아닌 내용을 기반으로 찾아야만 합니다.

### 데이터베이스 언어

- DDL (Data Definition Language) : 데이터베이스 구조를 정의, 수정, 삭제(alter, create, drop)하는 언어
- DML(Data Manipulate Language) : 데이터베이스 내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어 (select, insert, update, delete)
- DCL(Data Control Language) : 데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어( Commit, Rollback, Grant, Revoke)

### inner join

두 테이블에서 특정 조건을 만족하는 결과만 반환. \
(교집합), 두 테이블에서 존재하는 값만 반환.

### outer join

두 테이블에서 기준이 되는 테이블은 모든 결과를 반환하고, \
기준이 아닌 테이블은 조건에 만족하는 결과만 반환.

### Group By

그룹바이는 특정 컬럼을 기준으로 연산한 결과를 집계 키로 정의하여, \
그룹을 짓는 역할을 합니다.

집합 연산자는 count, sum, avg, max, min 등이 있고, \
distinct와 같이 중복 데이터를 제거하는 특징이 있습니다.

### Delete

데이터는 지우지만 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 수 있습니다. \
삭제 후 되돌릴 수 있습니다.

### Truncate

전체 데이터를 한번에 삭제하는 방식입니다. \
테이블 용량이 줄어들고 인덱스 등도 삭제되지만 테이블은 삭제할 수 없고,  \
삭제 후 되돌릴 수 없습니다.

### Drop

테이블 자체를 완전히 삭제하는 방식(공간, 인덱스, 객체 모두 삭제)입니다. \
삭제 후 되돌릴 수 없습니다.

### Having, Where의 차이

**having**은 그룹을 필터링 하는데 사용되고, \
**where**은 개별 행을 필터링하는데 사용됩니다.

집계 함수(COUNT, SUM, AVG, MAX, MIN 등)는 having절과 함께 사용할 수 있으나,\
where절은 사용할 수 없습니다.\
(집계함수를 사용할 수 있는 GROUP BY 절보다 WHERE절이 먼저 수행)

### 인덱스

인덱스란 테이블에 대한 동작의 속도를 높여주는 자료 구조를 의미합니다. \
인덱스는 항상 정렬된 상태를 유지하기 대문에 원하는 값을 검색하는데 빠르지만, \
새로운 값을 추가하거나, 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다는 단점이 있습니다.

즉, 인덱스는 데이터 저장 성능을 희생하는 대신, \
데이터의 검색 속도는 높이는 기능이라고 할 수 있습니다.

### 클러스터 인덱스와 넌클러스터 인덱스

클러스터 인덱스는 데이터 자체를 재배열하고, \
넌클러스터 인덱스는 인덱스 테이블을 생성한다는 차이점이 존재합니다.

클러스터드 인덱스는 인덱스를 생성할 때 데이터 페이지 전체를 다시 정렬하기 때문에, \
대용량 데이터에 클러스터드 인덱스를 생성하는 행위는 조심해야 합니다.

하지만 비클러스터 인덱스보다 검색 속도가 빠르다는 장점이 있습니다.

### mysql과 mongodb의 차이

mysql은 관계형 데이터 베이스로, \
정해진 데이터 스키마에 따라 테이블에 데이터를 저장하고 SQL을 이용해 DB에 접근.\
하나의 테이블에서 중복 없이 하나의 데이터만을 관리하기 때문에, \
다른 테이블에서 부정확한 데이터를 다룰 위험이 없음.

- 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에 중요 한 경우

NoSQL은 SQL과 반대되는 접근 방식을 따르는데, \
데이터 구조를 명시하지 않고, 구조가 다른 데이터들도 같은 컬렉션에 추가할 수 있음.

- 정확한 데이터 구조를 알 수 없거나, 변경/확장이 이루어 지는 경우
- 읽기 처리를 자주 하지만, 데이터를 자주 변경하지는 않는 경우

### mysql, nosql의 장단점

**SQL의 장점**

명확하게 정의 된 스키마, 데이터 무결성 보장

**NoSQL의 장점**

스키마가 없기때문에, 훨씬 더 유연합니다. \
즉, 언제든지 저장된 데이터를 조정하고 새로운 "필드"를 추가 할 수 있습니다.\
데이터는 애플리케이션이 필요로 하는 형식으로 저장됩니다. \
이렇게 하면 데이터를 읽어오는 속도가 빨라집니다.

**SQL의 단점**

관계를 맺고 있기 때문에, JOIN문이 많은 매우 복잡한 쿼리가 만들어 질 수 있습니다.

**NoSQL의 단점**

유연성 때문에, 데이터 구조 결정을 하지 못하고 미루게 될 수 있습니다.\
데이터가 여러 컬렉션에 중복되어 있기 때문에, \
수정(update)를 해야 하는 경우 모든 컬렉션에서 수행해야 함을 의미합니다. \
(SQL 세계에서는 중복된 데이터가 없기 때문에 한번만 수행하면 됩니다.)

### DB 트렌젝션 Transaction

데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위를 의미.\
트렌젝션이 성공하면 변경 사항이 시스템에 반영되고, \
트렌젝션이 실패하고 변경사항이 반영되지 않습니다.

- 원자성 : 트렌젝션의 연산이 DB에 모두 반영되거나, 전혀 반영되지 않거나 둘 중 하나만 수행되어야 한다
- 일관성: 트렌젝션이 성공된 후, 언제나 일관성 있는 Db 상태로 변환되어야 한다.
- 독립성 : 수행중인 트랜젝션이 완전히 완료되기 전에는 다른 트랜젝션에서 수행 결과를 참조할 수 없습니다.
- 지속성 : 성공한 트렌젝션의 결과는 시스템이 고장나더라도, 영구적으로 반영되어야 합니다.

### 프라이머리 키(기본키), 컴파운드 키

primary key는 모든 행 데이터가 고유하게 식별되는 열을 의미합니다. \
테이블의 모든 행에는 프라이머리 키가 존재해야 하고, \
두 개의 행이 동일한 프라이머리 키를 가질 수는 없습니다.

컴파운드 키는 두 개 이상의 열을 키로 지정하는 것을 의미합니다.

### Foreign Key

외래키는 두 테이블을 서로 연결하는 데 사용되는 키이다.

외래키가 포함된 테이블을 자식 테이블이라고 하고 외래키 값을 제공하는 테이블을 부모 테이블이라한다.

### db procedure

마치 프로그래밍 언어의 함수처럼, 쿼리문을 저장해 사용하는 방식

장점

1. 하나의 요청으로 여러 SQL문을 실행 할 수 있습니다.
2. 네트워크 소요 시간을 줄일 수 있습니다.
   - 만약 동일한 쿼리를 1000번 2000번 호출하는 것보다 SP를 이용해서 구현한다면 SP를 호출할 때 한 번만 네트워크를 경유하기 때문에 네트워크 소요시간을 줄이고 성능을 개선할 수 있습니다.
3. 개발 업무를 구분해 개발 할 수 있습니다.
   - 순수한 애플리케이션만 개발하는 조직과 DBMS 관련 코드를 개발하는 조직이 따로 있다면, DBMS 개발하는 조직에서는 데이터베이스 관련 처리하는 SP를 만들어 API처럼 제공하고 애플리케이션 개발자는 SP를 호출해서 사용하는 형식으로 역할을 구분하여 개발이 가능합니다.

단점

1. 처리 성능이 낮습니다.
   - 문자나 숫자 연산에 저장 프로시저를 사용한다면 오히려 C나 JAVA보다 느린 성능을 보여줍니다.
2. 디버깅이 어렵습니다.
3. DB 확장이 매우 힘듭니다.
   - 서비스 사용자가 많아져 서버수를 늘려야할 때, DB 수를 늘리는 것이 더 어렵습니다.
     - 서비스 확장을 위해 서버수를 늘릴경우 DB 수를 늘리는 것보다 WAS의 수를 늘리는 것이 더 효율적이기 때문에 대부분의 개발에서 DB에는 최소의 부담만 주고 대부분의 로직은 WAS에서 처리할 수 있게 합니다.

### SQL Injection

공격자가 악의적인 의도를 갖는 SQL 구문을 삽입하여,\
데이터베이스를 비정상적으로 조작하는 코드 인젝션 공격 방법.

### SQL Injection 방어 및 방지 방법

입력값을 검증해, 사용자의 입력이 쿼리에 동적으로 영향을 주는 경우엔\
입력된 값이 개발자가 의도한 값인지 확인한다.

또는, Query에 미리 형식을 지정하는 저장 프로시저를 사용한다.

### Elastic Search의 키워드 검색과 RDBMS의 LIKE 검색의 차이

RDBMS는 단순 텍스트매칭에 대한 검색만을 제공해 동의어나 유의어 같은 검색은 불가능.

하지만 엘라스틱 서치는 동의어나 유의어를 활용한 검색이 가능하며,\
비정형 데이터의 색인과 검색이 가능하고,\
역색인 지원으로 매우 빠른 검색이 가능하다.

### 옵티마이저

SQL을 가장 빠르고 효율적으로 수행할 최적의 처리 경로를 생성해주는 DBMS 내부 핵심 엔진.\
컴퓨터의 두뇌가 CPU인 것처럼, DBMS의 두뇌는 옵티마이저로,\
쿼리문이 들어왔을 때, 이 쿼리문의 실행 계획을 세우고, 최고 효율을 갖는 실행계획을 판별한 뒤\
쿼리를 수행한다.

### 데이터베이스 클러스터링

여러 개의 DB를 수평적인 구조로 구축하는 방식. 동기 방식으로 사용된다.

- 장점 :

  - DB 간의 데이터를 동기화하여 항상 일관성있는 데이터를 얻을 수 있다.
  - 1개의 DB가 죽어도 다른 DB가 살아 있어 시스템을 장애없이 운영할 수 있다.(높은 가용성)
  - 기존에 하나의 DB서버에 몰리던 부하를 여러 곳으로 분산시킬 수 있다. (로드밸런싱)

- 단점 :
  - 저장소 하나를 공유하면 병목현상이 발생할 수 있다.
  - 서버를 동시에 운영하기 위한 비용이 많이 든다.

### 데이터베이스 리플레케이션

여러 개의 DB를 권한에 따라 수직적인 구조로 구축하는 방식. 비동기 방식으로 사용된다.

- 장점 :

  - DB 요청의 60~80% 정도가 읽기 작업이기 때문에 Replication만으로도 충분히 성능을 높일 수 있다.
  - 비동기 방식으로 운영되어 지연 시간이 거의 없다.

- 단점 :
  - 노드들 간 데이터 동기화가 보장되지 않아 일관성있는 데이터를 얻지 못할 수 있다.
  - Master DB가 다운되면 복구 및 대처가 까다롭다.

### 웹사이트 접속 순서

1. 브라우저에 URL을 입력
2. ISP에서 DNS 조회를 통해 도메인에 해당하는 웹 사이트를 호스팅하는 서버의 IP를 얻어옴
3. 브라우저와 2번에서 얻어온 서버와 TCP 연결 수행
4. 웹 페이지의 콘텐츠를 받아오기 위해 브라우저에서 HTTP 요청을 서버에 전송
5. 서버에서 요청을 처리하고, 응답을 전송
6. 웹 브라우저가 콘텐츠 렌더링

### HTTP, HTTPS란?

HTTP(Hyper Text Transfer Protocol)이란 데이터를 주고 받기 위한 프로토콜.

상태 정보를 저장하지 않는 Stateless의 특징과 \
클라이언트의 요청에 맞는 응답을 보낸 후 연결을 끊는 Connectionless의 특징을 가지고 있습니다.

HTTP는 평문 데이터를 전송하는 프로토콜이기 때문에, \
HTTP로 중요한 정보를 주고 받으면 제 3자에 의해 데이터가 조회될 수 있습니다. \
이러한 문제를 해결하기 위해 HTTP에 암호화를 추가한 프로토콜이 바로 HTTPS입니다.

HTTP는 TCP와 직접 통신했지만, HTTPS에서는 HTTP는 SSL과 통신하고, \
SSL이 TCP와 통신함으로서 암호화화 증명서, 안전성 보호를 이용할 수 있게 되었습니다.

### 쿠키, 세션

쿠키는 사용자 컴퓨터에 저장하는 작은 정보 파일로, \
HTTP에서 클라이언트의 상태 정보를 PC에 저장하고, \
필요시 정보를 참조하거나 재사용할 수 있습니다.

세션은 일정 시간동안 같은 사용자로부터 들어오는 정보나 요청을 하나의 상태로 보고, \
그 상태를 유지시키는 기술을 의미합니다.

세션은 서버 측에서 관리되기 때문에, \
쿠키보다 속도가 느리지만, 보안이 좋다는 장점이 존재합니다.

### GET/POST

GET은 클라이언트에서 서버로 정보를 요청하기 위해 사용되는 메소드입니다. \
GET을 통한 요청은 쿼리스트링을 사용해 소용량의 데이터를 전송할 수 있습니다. \
URL에 데이터가 노출되기 때문에, 보안적으로 중요한 데이터를 포함해서는 안됩니다.

Post는 클라이언트에서 서버로 리소스를 생성하거나, \
업데이트 하기 위해 데이터를 전송할 때 사용하는 메소드입니다.\
Post를 통한 요청은 HTTP 메세지의 Body에 담아 대용량의 데이터를 서버에 전송할 수 있습니다. \
URL에 데이터가 노출되는 GET 요청에 비해 비교적 안전합니다.

### TCP와 UDP의 차이

TCP는 연결형 서비스로, 통신 장치간의 연결 상태를 확인하는 \
3-way handshaking 과정을 통해 연결하기 때문에 높은 신뢰도를 보장하지만, \
속도가 비교적 느리다는 장점이 있습니다.

UDP는 비연결형 서비스로, 정보를 보내는 쪽에서 일방적으로 데이터를 전달하기 때문에 \
속도가 빠르다는 장점이 존재하지만, TCP에 비해 신뢰도가 떨어진다는 단점이 존재합니다.

TCP는 주로 신뢰성이 중요한 파일 교환과 같은 경우 사용되고, \
UDP는 실시간성이 중요한 스트리밍에 주로 사용됩니다.

TCP가 연결이 종료될 땐 4-way handshaking 과정을 통해 연결을 해제합니다.

### 3-way handshaking, 4-way handshaking

3 way handshaking은 TCP 네트워크에서 서로 통신하는 장치가 서로 잘 연결되었는지 확인하는 방법입니다. \
송신자와 수신자는 총 세번에 걸쳐 데이터를 주고 받으며, \
통신이 서로 가능한 상태인지 확인합니다.

4 way handshaking은 TCP 네트워크에서 통신하고 있는 장치 사이의 연결을 해제하는 방법입니다. \
송신자와 수신자는 총 네 번의 걸쳐 데이터를 주고받으며, 연결을 해제합니다.

### OSI 7 Layer

- 7 계층(응용 계층) : 사용자에게 통신을 위한 서비스 제공. 인터페이스 역할
- 6 계층(표현 계층) : 데이터의 형식(Format)을 정의하는 계층 (코드 간의 번역을 담당)
- 5 계층(세션 계층) : 컴퓨터끼리 통신을 하기 위해 세션을 만드는 계층
- 4 계층(전송 계층) : 최종 수신 프로세스로 데이터의 전송을 담당하는 계층 (단위 :Segment) (ex. TCP, UDP)
- 3 계층(네트워크 계층) : 패킷을 목적지까지 가장 빠른 길로 전송하기 위한 계층 (단위 :Packet) (ex. Router)
- 2 계층(데이터링크 계층) : 데이터의 물리적인 전송과 에러 검출, 흐름 제어를 담당하는 계층 (단위 :frame) (ex. 이더넷)
- 1 계층(물리 계층) : 데이터를 전기 신호로 바꾸어주는 계층 (단위 :bit) (장비: 케이블,리피터,허브)

### 세션 기반 인증과 토큰 기반 인증

세션 기반 인증은 클라이언트로부터 요청을 받으면 \
클라이언트의 상태 정보를 저장하므로 Stateful한 구조를 가지고, \
토큰 기반 인증은 상태 정보를 서버에 저장하지 않으므로 Stateless한 구조를 가집니다.

세션 기반 인증은 사용자가 증가하게 되면 서버에 과부화를 줄 수 있어 확장성이 낮고, \
제 3자가 탈취한 뒤 요청을 전송하게 되면, \
이 요청에 대해 서버는 올바른 사용자가 보낸 요청인지 알 수 없습니다.

### 세션 기반 인증과 토큰 기반 인증이 적합한 경우

단일 도메인이라면 세션 기반 인증을, 아니라면 토큰 기반 인증을 사용하는 것이 적합하다고 생각됩니다. \
일반적으로 세션을 관리할 때 사용되는 쿠키는 \
단일 도메인 및 서브 도메인에서만 작동하도록 설계되어 있기 때문에, \
CORS 문제로 인해 여러 도메인에서 관리하는 것은 어렵다고 생각됩니다.

### JWT

JWT는 JSON 포맷을 이용하는 Claim 기반의 웹 토큰이며, \
토큰 자체를 정보로 사용하는 Self-Contained 방식으로 정보를 안전하게 전달합니다.

JWT는 헤더(Header).내용(Payload).서명(Signature)로 구성되며 각 파트를 점(.)으로 구분합니다.

- **헤더(Header) :** 토큰의 타입과 해시 암호화 알고리즘(방식지정)으로 이루어져 있다.
- **내용(Payload) :** 토큰에 사용자가 담고자 하는 정보를 담는다. \
   내용에는 Claim이 담겨있고, JSON(Key/Value)형태의 한 쌍으로 이루어져 있다.
- **서명(Signature) :** 토큰을 인코딩하거나 유효성 검증할 때 사용하는 고유한 암호화 코드이다. 헤더와 내용의 값을 인코딩한다.

### HTTP 상태 코드

https://developer.mozilla.org/ko/docs/Web/HTTP/Status

### 운영체제

컴퓨터 하드웨어가 컴퓨터 소프트웨어와 통신하고, 작동하도록 하는 소프트웨어 프로그램

### 프로세스의 특징

프로세스란 컴퓨터에서 실행되고 있는 프로그램을 의미합니다.

- 각 프로세스는 독립된 메모리 영역 ( Code, Data, Stack, Heap )을 할당 받는다.
- 각 프로세스는 최소 한 개의 쓰레드를 가지고 있다.
- 각 프로세스는 별도의 주소 공간에서 실행되며, 한 프로세스는 다른 프로세스의 변수나 자료 구조에 접근할 수 없다.
- 한 프로세스가 다른 프로세스의 자원에 접근하기 위해선 파이프, 파일, 소켓 등의 프로세스간 통신을 사용해야 합니다.

### 스레드의 특징

쓰레드는 CPU 사용의 기본 단위로, 프로세스 내에서 실행되는 여러 흐름의 단위를 의미합니다.

- 쓰레드는 프로세스 내에서 Stack 영역만 따로 할당받고, Code, Data, Heap 영역은 공유됩니다.
- 한 쓰레드가 프로세스의 자원을 변경하면, 다른 이웃 쓰레드는 그 변경 결과를 즉시 확인할 수 있습니다.

### 프로세스와 쓰레드의 차이

프로세스는 메모리에 적재되어 실행되고 있는 프로그램을 말하고, \
쓰레드는 프로세스 내에서 실행되는 흐름을 의미합니다.

쓰레드는 프로세스 내에서 스택 영역만 따로 할당받고, \
이외의 메모리 영역을 공유하기 때문에 다른 쓰레드의 실행 결과를 확인할 수 있습니다.

### 메모리 영역

- 코드 : 실행할 프로그램의 코드가 저장되는 텍스트 영역

- 데이터 : 전역 변수완 정적 변수가 저장되는 영역으로, 프로그램의 시작과 함께 할당되어, 프로그램이 종료되면 소멸됩니다.

- 스택 : 함수 호출과 관계된 지역변수, 매개변수가 저장되는 영역, 함수 호출과 함께 할당되며, 함수 호출이 종료될 때 해제됩니다.

- 힙 : 사용자가 직접 관리할 수 있는 메모리 영역

### 멀티 프로세스와 멀티 스레드의 특징

멀티 프로세스는 하나의 프로세스가 죽어도 다른 스로세스에 영향을 끼치지 않고, \
계속 실행된다는 장점이 있지만, 멀티 쓰레드보다 많은 메모리 공간, \
그리고 CPU 시간을 차지한다는 단점이 존재합니다.

멀티 쓰레드는 멀티 프로세스보다 적은 메모리 공간을 차지하고, \
문맥 전환도 빠르다는 장점이 있지만, \
하나의 쓰레드에 문제가 생기면 전체 쓰레드가 영향을 받으며,\
동기화 문제가 발생한다는 단점이 존재합니다.

### 멀티 스레드의 동시성과 병렬성

동시성은 멀티 쓰레드 작업을 위해 싱글 코어에서 여러 개의 쓰레드가 번갈아 가며 실행되는 것을 말합니다. \
병렬성은 멀티 작업을 위해 멀티코어에서 한 개 이상의 쓰레드를 포함하는 코어들을 동시에 실행하는 것을 의미합니다.

### 멀티 쓰레드 환경 주의사항

여러 개의 쓰레드가 공유 데이터에 접근하는 경우, \
상호 배제, 혹은 동기화 기법을 통해 동시성 문제나 교착상태가 발생하지 않도록 주의해야 합니다.

### 데드락

둘 이상의 프로세스들이 자원을 점유한 상태에서 서로 다른 프로세스가 점유하고 있는 자원을 요구하며, \
무한정 기다리는 상황을 의미합니다.

### 데드락의 조건

- 비선점 : 다른 프로세스의 자원을 뺏을 수 없음
- 순환 대기 : 두 개 이상의 프로세스가 자원 접근을 기다릴 때, 그 관계가 순환 구조
- 점유 대기 : 공유 자원에 대한 접근 권한을 가진 채로 다른 자원에 대한 접근 권한을 요구
- 상호 배제 : 한 번에 한 프로스세만 공유 자원에 접근 가능하며, 접근 권한이 제한적일 경우

### 콘보이 현상

작접시간이 긴 프로세스가 먼저 큐에 도작하여, \
다른 프로세스들의 실행 시간이 전부 늦춰져 효율성을 떨어트리는 현상을 의미합니다.

대표적으로 First Come, First Served 스케쥴링은 비선점형으로, \
콘보이 현상이 발생할 수 있습니다.

### 선점형 스케쥴린, 비선점형 스케쥴링의 차이

선점형 : 하나의 프로세스가 다른 프로세스 대신에 CPU를 차지할 수 없음.

비선점형 : 하나의 프로세스가 끝나지 않으면 다른 프로세스는 CPU를 사용할 수 없음

### 동기와 비동기

동기는 순차적, 직렬적으로 테스크를 수행하고, \
비동기는 병렬적으로 테스크를 수행합니다.

에를 들어, 서버에서 데이터를 가져와 화면에 출력하는 작업이 있다고 가정할 때, \
동기는 서버에 데이터를 요청한 뒤 데이터가 응답될 때까지, \
이후 테스크들은 작업 중단 됩니다.

비동기는 서버에 데이터를 요청한 후 서버로부터 데이터가 응답될 때까지 대기하지 않고,\
즉시 다음 테스크를 계속 수행합니다.

### 임계 영역, Critical Section

임계 영역이란 프로세스간에 공유자권을 접근하는데 있어서, \
문제가 방생하지 않도록 한번에 하나의 프로세스만 이용하게끔 \
보장해줘야 하는 영역을 의미합니다.

임계 영역 문제를 해결하기 위해선 아래 세 가지 조건을 충족해야 합니다.

- 상호 배제 : 하나의 프로세스가 임계 영역에 들어가 있다면, 다른 프로세스는 들어갈 수 없다.
- 진행 : 임계 영역에 들어간 프로세스가 없는 상태에서, 들어가려 하는 프로세스가 여러 개라면 어느 것이 들어갈 지 결정해줘야 한다.
- 한정 대기 : 다른 프로세스의 기아를 방지하기 위해, 한번 임계 구역에 들어간 프로세스는 다음번 임계 영역에 들어갈 때 제한을 두어야 한다.

### 뮤텍스와 세마포어

뮤텍스는 Locking 메커니즘을 사용해 하나의 프로세스나 쓰레드만이 \
단독으로 실행될 수 있도록 합니다. \
Lock을 획득하여 실행하고, \
Lock을 획득한 프로세스가 그 Lock을 해제해야 합니다.

세마포어는 공유 자원에 세마포어 변수 값 만큼 쓰레드의 접근을 허용합니다. \
Signaling 매커니즘으로, 락을 걸지 않은 쓰레드도 Signal을 보내 락을 해제할 수 있습니다.

### 가상 메모리

프로세스가 메모리 외부에서 실행될 수 있도록 하는 메모리 관리 기술.

### 싱글톤 패턴

단 하나의 인스턴스만을 생성해 사용하는 디자인 패턴.\
인스턴스가 한개만 존재해야 한다는 것을 보장하고 싶은 경우, \
혹은 동일한 인스턴스를 자주 생성해야 하는 경우에 주로 사용한다.

대표적으로, Spring Bean이 이 싱글톤 패턴을 사용하고 있다.

### AOP

관점 지향 프로그래밍의 약자로, \
핵심 비즈니스 로직에 있는 공통 관심사항을 분리하고, 각각을 모듈화하는 것을 의미한다.\
공통 모듈인 인증, 로깅, 트랜젝션 처리에 용이한다.

핵심 비즈니스 로직에 부가기능을 하는 모듈이 중복되어 분포되어 있을 경우 사용할 수 있으며,\
중복 코드를 제거할 수 있고, 재활용성의 극대화의 장점이 있다.

### IoC

제어의 역전은 모든 객체의 생성, 라이프사이클 등의 제어권을\
개발자가 아닌, IoC 컨테이너에게 넘기는 것을 의미한다.

스프링에선 IoC 컨테이너에 객체들을 생성하면 \
객체끼리 DI를 통해 의존성을 주입하고, 이렇게 컨테이너에 등록된 객체들을 빈이라고 한다.

### DI

의존성 주입의 약자로, 객체들간 의존성을 줄이기 위해 사용되는 \
스프링 IOC 컨테이너의 구체적인 구현 방식을 의미한다.

필드 주입과 setter, 생성자 주입, 세가지 방법을 사용해 구현할 수 있다.

개발 코드 부분에서 객체를 생성하는 것이 아니라,\
데이터 주입만 담당하는 별도의 공간에서 객체를 생성하고,\
데이터 간의 의존성을 주입해 개발코드에서 가져다 쓰면서 의존성을 줄일 수 있다.

### Bean

Spring IoC 컨테이너가 관리하는 자바 객체.\
즉, 스프링 컨테이너가 생성한 객체들을 빈이라고 부른다.

스프링에선 @Component 어노테이션을 사용해 빈을 등록할 수 있다.\
혹은, Configuration 클래스를 따로 생성해, \
해당 클래스 안에서 빈으로 등록할 메소드에 Bean 어노테이션을 붙여주면 된다.

### 스프링 필터와 인터셉터의 차이점

컨트롤러에 들어가기 전, 작업을 처리하기 위해 사용된다는 공통점이 있지만,\
실행되는 시점에서 차이가 존재한다.\
필터는 dispatcherServlet으로 요청이 전달되기 전에 실행되고,\
인터셉터는 Controller로 요청이 전달되기 전에 실행된다.

### Entity

데이터베이스의 테이블과 1:1로 매핑되는 클래스.\
DB의 테이블내에 존재하는 컬럼만을 속성으로 가져야 한다.

### Object

객체란, 소프트웨어 세계에 구현할 대상을 의미한다.\
클래스의 인스턴스라고도 부르며, OOP 관점에서 볼 때 클래스의 타입으로 선언된다면 객체라고 부른다.

### Instance

객체를 소프트웨어에 실체화하면, 이를 인스턴스라고 부른다.\
OOP의 관점에서, 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.

### 인스턴스화 된다가 무슨 의미인가

클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 한다.\
어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.

### JPA에서 Entity를 설계할 때 주의점

1. Entity엔 가급적 Setter를 사용하지 않는다.

   - Entity의 영속성이 유지되는 도중 값이 수정된다면, 그 값이 DB에 반영된다.\
     이 때 Setter를 열어둔다면 변경 포인트를 모두 트래킹하기 어렵기 때문에,\
     유지보수가 다소 어려워질 수 있다.

2. 모든 연관관계는 지연로딩으로 설정한다.

   - 즉시로딩(Eager)를 사용할 경우, 의도치 않게 많은 양의 SQL문이 발생할 수 있다.

3. 컬렉션은 필드에서 바로 초기화한다.

### DTO를 사용하는 이유

1. 순환참조를 예방할 수 있다.
   - JPA로 개발할 때, 양방향 참조를 사용한다면 순환참조를 조심해야 한다.
2. 엔티티 내부 구현을 캡슐화할 수 있다.
3. DB 레이어와 View 레이어 사이의 역할을 분리하기 위해

### N+1 문제

한 번의 쿼리를 날렸을 때, 의도하지 않은 N번의 쿼리가 \
추가적으로 실행되는 현상을 의미한다.

이는 주로 연관관계를 가진 엔티티를 조회할 때, 한 쪽 테이블만 조회하고\
연결된 다른 테이블을 따로 조회하기 때문에 발생한다.

Fetch Join을 사용할 경우, 미리 두 테이블을 Join하여 \
한 번에 모든 데이터를 가져오기 때문에, N + 1 문제를 방지할 수 있다.

### 생성자 Injection을 사용하는 이유

생성자 주입은 먼저 빈을 생성하는 것이 아닌, 주입하려는 빈을 찾는다.\
따라서 실행시 바로 순환참조 오류가 발생하여, 순환참조를 방지할 수 있다.

또한 final 선언을 통해 객체를 변경할 수 없도록 막을 수 있으며,\
DI 컨테이너 없이도 테스트 코드의 작성이 용이하다는 장점이 존재한다.

### 테스트코드를 사용하는 이유

개발 초기에 문제점을 발견할 수 있고, 예기치 않은 문제 발생을 방지할 수 있다.

### JPA

자바 ORM 기술에 대한 API 표준 명세를 의미한다.\
Hibernate는 JPA라는 명세의 구현체이다.

### JPA의 장점과 단점

JPA를 사용할 경우 SQL의 반복 작업이 없어져 생산성이 증가하고,\
Entity를 사용하여 유지보수성이 증가한다는 장점이 존재한다.

하지만 직접 SQL을 호출하는 것보다 성능이 떨어질 수 있고,\
복잡한 통계 분석 쿼리를 메소드 호출로 처리하기 힘들다는 단점이 존재한다.

### MVC 진행 방식

1. 클라이언트로 요청이 들어오면, dispatcherServlet이 가장 먼저 받는다.
2. HandlerMapping이 요청 URL과 매핑되는 Controller를 검색하고, 반환.
3. HandlerAdapter에서 알맞은 controller 처리를 요청한다.
4. ViewResolver에서 controller가 반환한 view를 검색한 뒤, 해당 view를 클라이언트에 전송한다.

### Spring Security

스프링 기반 어플리케이션의 보안(인증, 권한 등)을 담당하는 프레임워크.\
일반적으로, Session-Cookie 방식으로 인증한다.

### JWT, OAuth

### 영속성 컨텍스트

엔티티를 영구 저장하는 환경. \
EntityManager는 영속성 컨텍스트에 Entity를 보관하고, 관리한다.

영속성 컨텍스트를 사용하면 1차 캐시를 사용해 응답 속도를 높일 수 있으며,\
데이터의 동일성을 보장하고, 쓰기 지연, 변경 감지, 지연 로딩 등의 장점이 존재한다.

### @RequestBody, @RequestParam, @ModelAttribute

- @RequestBody

  - 클라이언트가 전송하는 JSON 형태의 HTTP Body 내용을 \
    MessageConverter를 통해 Java Object로 변환시켜주는 역할을 한다.

- @RequestParam

  - 1개의 HTTP 요청 파라미터를 받기 위해 사용. \
    @RequestParam은 필수 여부가 true이기 때문에,\
    기본적으로 반드시 해당 파라미터가 전송되어야 한다.

- @ModelAttribute
  - HTTP Body 내용과 HTTP 파라미터의 값들을 생성자, \
    Getter,Setter를 통해 주입하기 위해 사용한다.\
    값 변환이 아닌 값을 주입시키므로, 변수들의 생성자나 \
    Getter,Setter가 없으면 변수들이 저장되지 않는다.

### Lombok 라이브러리

롬복은 메소드를 컴파일 하는 과정에 개입해, 추가적인 코드를 생성한다.\
이를 어노테이션 프로세싱이라 하며, 롬복은 이를 통해\
Getter, Setter 등 다양한 추가 코드를 생성해준다.

### Servlet

클라이언트의 요청을 처리하고, \
그 결과를 반환하는 Servlet 클래스의 구현 규칙을 지킨 자바 웹 프로그래밍 기술.

Spring MVC에서 Controller로 이용되며,\
사용자의 요청을 받아 처리한 후, 결과를 반환한다.\
쉽게 말해, 자바를 사용해 웹을 만들기 위해 필요한 기술이다.

### @Transactional의 동작 원리

Transactional 어노테이션을 메소드나 클래스에 명시하게 되면\
AOP를 통해 Target이 상속하고 있는 인터페이스, 혹은\
Target 객체를 상속한 Proxy 객체가 생성된다.

Proxy 객체의 메소드를 호출하면 Target 메소드 전, 후로 트랜젝션 처리를 수행한다.

### @Transactional의 readOnly를 사용하는 이유

트랜젝션 안에서 수정/삭제 작업이 아닌 조회 목적인 경우에 주로 사용하며,\
영속성 컨텍스트에서 엔티티를 관리할 필요가 없기 때문에, \
메모리 성능을 높일 수 있다는 장점이 존재한다.

### Wrapper Class

기본 자료형에 대한 객체 표현 방식을 Wrapper Class라고 한다. \
기본 자료형을 래퍼 클래스로 변환하는걸 Boxing, \
그 반대를 UnBoxing이라 한다.

### String, StringBuffer, StringBuilder

- String은 불변의 속성을 가지며, StringBuffer와 StringBuilder는 가변의 속성을 가짐.
- StringBuffer는 동기화를 지원하여 멀티 쓰레드 환경에서 주로 사용.
- StringBuilder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용.

### String 객체가 불변인 이유

1. 캐싱 기능에 의한 메모리 절약과 속도 향상
   - JAVA에서 String 객체들은 Heap의 String Pool이라는 공간에 저장된다. \
     참조하려는 문자열이 String Pool에 존재하는 경우, Pool에 있는 객체를 사용한다.
2. thread-safe
   - String 객체를 불변으로 두어, 여러 쓰레드에서 동시에 \
     특정 String 객체를 참조하더라도 안전함을 보장한다.
3. 보안기능
   - 강제로 해당 참조에 대한 문자열을 변경하는것이 불가능하다.

## 참고

https://dev-coco.tistory.com/163

https://wookcode.tistory.com/99
