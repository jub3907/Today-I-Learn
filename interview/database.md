## 목차

[데이터베이스의 특징](#데이터베이스의-특징)\
[데이터베이스 언어](#데이터베이스-언어)\
[inner join](#inner-join)\
[outer join](#outer-join)\
[Group By](#Group-By)\
[Delete](#Delete)\
[Truncate](#Truncate)\
[Drop](#Drop)\
[Having, Where의 차이](#Having,-Where의-차이)\
[인덱스](#인덱스)\
[클러스터 인덱스와 넌클러스터 인덱스](#클러스터-인덱스와-넌클러스터-인덱스)\
[mysql과 mongodb의 차이](#mysql과-mongodb의-차이)\
[mysql, nosql의 장단점](#mysql,-nosql의-장단점)\
[DB 트렌젝션 Transaction](#DB-트렌젝션-Transaction)\
[프라이머리 키, 컴파운드 키](#프라이머리-키,-컴파운드-키)\
[db procedure](#db-procedure)

### 데이터베이스의 특징

실시간 처리에 대한 응답이 가능해야하며, \
새로운 데이터 삽입, 삭제, 갱신으로 항상 최신 데이터가 유지되어야 합니다.

또한 서로 다른 목적을 갖는 여러 사용자를 위한 것이므로, \
다수의 사용자가 동시에 같은 내용의 데이터를 이용할 수 있어야하고, \
데이터를 참조할 때, 데이터의 위치가 아닌 내용을 기반으로 찾아야만 합니다.

### 데이터베이스 언어

- DDL (Data Definition Language) : 데이터베이스 구조를 정의, 수정, 삭제(alter, create, drop)하는 언어
- DML(Data Manipulate Language) : 데이터베이스 내의 자료 검색, 삽입, 갱신, 삭제를 위한 언어 (select, insert, update, delete)
- DCL(Data Control Language) : 데이터에 대해 무결성 유지, 병행 수행 제어, 보호와 관리를 위한 언어( Commit, Rollback, Grant, Revoke)

### inner join

두 테이블에서 특정 조건을 만족하는 결과만 반환. \
(교집합), 두 테이블에서 존재하는 값만 반환.

### outer join

두 테이블에서 기준이 되는 테이블은 모든 결과를 반환하고, \
기준이 아닌 테이블은 조건에 만족하는 결과만 반환.

### Group By

그룹바이는 특정 컬럼을 기준으로 연산한 결과를 집계 키로 정의하여, \
그룹을 짓는 역할을 합니다.

집합 연산자는 count, sum, avg, max, min 등이 있고, \
distinct와 같이 중복 데이터를 제거하는 특징이 있습니다.

### Delete

데이터는 지우지만 테이블 용량은 줄어들지 않고 원하는 데이터만 골라서 지울 수 있습니다. \
삭제 후 되돌릴 수 있습니다.

### Truncate

전체 데이터를 한번에 삭제하는 방식입니다. \
테이블 용량이 줄어들고 인덱스 등도 삭제되지만 테이블은 삭제할 수 없고,  \
삭제 후 되돌릴 수 없습니다.

### Drop

테이블 자체를 완전히 삭제하는 방식(공간, 인덱스, 객체 모두 삭제)입니다. \
삭제 후 되돌릴 수 없습니다.

### Having, Where의 차이

**having**은 그룹을 필터링 하는데 사용되고, \
**where**은 개별 행을 필터링하는데 사용됩니다.

집계 함수(COUNT, SUM, AVG, MAX, MIN 등)는 having절과 함께 사용할 수 있으나,\
where절은 사용할 수 없습니다.\
(집계함수를 사용할 수 있는 GROUP BY 절보다 WHERE절이 먼저 수행)

### 인덱스

인덱스란 테이블에 대한 동작의 속도를 높여주는 자료 구조를 의미합니다. \
인덱스는 항상 정렬된 상태를 유지하기 대문에 원하는 값을 검색하는데 빠르지만, \
새로운 값을 추가하거나, 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려진다는 단점이 있습니다.

즉, 인덱스는 데이터 저장 성능을 희생하는 대신, \
데이터의 검색 속도는 높이는 기능이라고 할 수 있습니다.

### 클러스터 인덱스와 넌클러스터 인덱스

클러스터 인덱스는 데이터 자체를 재배열하고, \
넌클러스터 인덱스는 인덱스 테이블을 생성한다는 차이점이 존재합니다.

클러스터드 인덱스는 인덱스를 생성할 때 데이터 페이지 전체를 다시 정렬하기 때문에, \
대용량 데이터에 클러스터드 인덱스를 생성하는 행위는 조심해야 합니다.

하지만 비클러스터 인덱스보다 검색 속도가 빠르다는 장점이 있습니다.

### mysql과 mongodb의 차이

mysql은 관계형 데이터 베이스로, \
정해진 데이터 스키마에 따라 테이블에 데이터를 저장하고 SQL을 이용해 DB에 접근.\
하나의 테이블에서 중복 없이 하나의 데이터만을 관리하기 때문에, \
다른 테이블에서 부정확한 데이터를 다룰 위험이 없음.

- 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에 중요 한 경우

NoSQL은 SQL과 반대되는 접근 방식을 따르는데, \
데이터 구조를 명시하지 않고, 구조가 다른 데이터들도 같은 컬렉션에 추가할 수 있음.

- 정확한 데이터 구조를 알 수 없거나, 변경/확장이 이루어 지는 경우
- 읽기 처리를 자주 하지만, 데이터를 자주 변경하지는 않는 경우

### mysql, nosql의 장단점

**SQL의 장점**

명확하게 정의 된 스키마, 데이터 무결성 보장

**NoSQL의 장점**

스키마가 없기때문에, 훨씬 더 유연합니다. \
즉, 언제든지 저장된 데이터를 조정하고 새로운 "필드"를 추가 할 수 있습니다.\
데이터는 애플리케이션이 필요로 하는 형식으로 저장됩니다. \
이렇게 하면 데이터를 읽어오는 속도가 빨라집니다.

**SQL의 단점**

관계를 맺고 있기 때문에, JOIN문이 많은 매우 복잡한 쿼리가 만들어 질 수 있습니다.

**NoSQL의 단점**

유연성 때문에, 데이터 구조 결정을 하지 못하고 미루게 될 수 있습니다.\
데이터가 여러 컬렉션에 중복되어 있기 때문에, \
수정(update)를 해야 하는 경우 모든 컬렉션에서 수행해야 함을 의미합니다. \
(SQL 세계에서는 중복된 데이터가 없기 때문에 한번만 수행하면 됩니다.)

### DB 트렌젝션 Transaction

데이터베이스의 일관성 있는 상태를 다른 상태로 변경하는 작업 순서를 의미합니다. \
트렌젝션 완료 후, 성공적인 완료가 시스템에 반영되거나, \
트렌젝션이 실패하고 변경사항이 반영되지 않습니다.

- 원자성 : 트렌젝션의 연산이 DB에 모두 반영되거나, 전혀 반영되지 않거나 둘 중 하나만 수행되어야 한다
- 일관성: 트렌젝션이 성공된 후, 언제나 일관성 있는 Db 상태로 변환되어야 한다.
- 독립성 : 수행중인 트랜젝션이 완전히 완료되기 전에는 다른 트랜젝션에서 수행 결과를 참조할 수 없습니다.
- 지속성 : 성공한 트렌젝션의 결과는 시스템이 고장나더라도, 영구적으로 반영되어야 합니다.

### 프라이머리 키, 컴파운드 키

primary key는 모든 행 데이터가 고유하게 식별되는 열을 의미합니다. \
테이블의 모든 행에는 프라이머리 키가 존재해야 하고, \
두 개의 행이 동일한 프라이머리 키를 가질 수는 없습니다.

컴파운드 키는 두 개 이상의 열을 키로 지정하는 것을 의미합니다.

### db procedure

마치 프로그래밍 언어의 함수처럼, 쿼리문을 저장해 사용하는 방식

장점

1. 하나의 요청으로 여러 SQL문을 실행 할 수 있습니다.
2. 네트워크 소요 시간을 줄일 수 있습니다.
   - 만약 동일한 쿼리를 1000번 2000번 호출하는 것보다 SP를 이용해서 구현한다면 SP를 호출할 때 한 번만 네트워크를 경유하기 때문에 네트워크 소요시간을 줄이고 성능을 개선할 수 있습니다.
3. 개발 업무를 구분해 개발 할 수 있습니다.
   - 순수한 애플리케이션만 개발하는 조직과 DBMS 관련 코드를 개발하는 조직이 따로 있다면, DBMS 개발하는 조직에서는 데이터베이스 관련 처리하는 SP를 만들어 API처럼 제공하고 애플리케이션 개발자는 SP를 호출해서 사용하는 형식으로 역할을 구분하여 개발이 가능합니다.

단점

1. 처리 성능이 낮습니다.
   - 문자나 숫자 연산에 저장 프로시저를 사용한다면 오히려 C나 JAVA보다 느린 성능을 보여줍니다.
2. 디버깅이 어렵습니다.
3. DB 확장이 매우 힘듭니다.
   - 서비스 사용자가 많아져 서버수를 늘려야할 때, DB 수를 늘리는 것이 더 어렵습니다.
     - 서비스 확장을 위해 서버수를 늘릴경우 DB 수를 늘리는 것보다 WAS의 수를 늘리는 것이 더 효율적이기 때문에 대부분의 개발에서 DB에는 최소의 부담만 주고 대부분의 로직은 WAS에서 처리할 수 있게 합니다.
